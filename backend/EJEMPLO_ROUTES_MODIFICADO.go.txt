// EJEMPLO: Cómo modificar routes.go para soportar SMTP + SendGrid
// Este archivo NO debe ejecutarse, es solo un ejemplo de referencia
//
// INSTRUCCIONES:
// 1. Abre cmd/api/routes.go
// 2. Busca la función setupAuthRoutes
// 3. Reemplaza la sección de notifier (líneas ~40) con el código de abajo

package main

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"

	authHandler "github.com/sorteos-platform/backend/internal/adapters/http/handler/auth"
	raffleHandler "github.com/sorteos-platform/backend/internal/adapters/http/handler/raffle"
	websocketHandler "github.com/sorteos-platform/backend/internal/adapters/http/handler/websocket"
	"github.com/sorteos-platform/backend/internal/adapters/http/middleware"
	"github.com/sorteos-platform/backend/internal/adapters/db"
	redisAdapter "github.com/sorteos-platform/backend/internal/adapters/redis"
	"github.com/sorteos-platform/backend/internal/adapters/notifier"
	"github.com/sorteos-platform/backend/internal/usecase/auth"
	raffleuc "github.com/sorteos-platform/backend/internal/usecase/raffle"
	"github.com/sorteos-platform/backend/internal/infrastructure/websocket"
	redisinfra "github.com/sorteos-platform/backend/internal/infrastructure/redis"
	"github.com/sorteos-platform/backend/pkg/config"
	"github.com/sorteos-platform/backend/pkg/logger"
)

// setupAuthRoutes configura las rutas de autenticación
func setupAuthRoutesEjemplo(router *gin.Engine, gormDB *gorm.DB, rdb *redis.Client, cfg *config.Config, log *logger.Logger) {
	// Inicializar repositorios
	userRepo := db.NewUserRepository(gormDB)
	consentRepo := db.NewUserConsentRepository(gormDB)
	auditRepo := db.NewAuditLogRepository(gormDB)

	// Inicializar token manager
	tokenMgr := redisAdapter.NewTokenManager(rdb, &cfg.JWT)

	// Inicializar blacklist service
	blacklistService := redisinfra.NewTokenBlacklistService(rdb)

	// =====================================================================
	// MODIFICACIÓN: Inicializar notifier según configuración
	// =====================================================================
	var emailNotifier notifier.Notifier

	if cfg.EmailProvider == "smtp" {
		emailNotifier = notifier.NewSMTPNotifier(&cfg.SMTP, log)
		log.Info("Email provider configured",
			logger.String("provider", "smtp"),
			logger.String("host", cfg.SMTP.Host),
			logger.Int("port", cfg.SMTP.Port),
		)
	} else {
		emailNotifier = notifier.NewSendGridNotifier(&cfg.SendGrid, log)
		log.Info("Email provider configured",
			logger.String("provider", "sendgrid"),
		)
	}
	// =====================================================================

	// Inicializar middlewares
	authMiddleware := middleware.NewAuthMiddleware(tokenMgr, blacklistService, log)
	rateLimiter := middleware.NewRateLimiter(rdb, log)

	// Inicializar use cases
	// CAMBIO: Usar emailNotifier en vez de sendgridNotifier
	registerUseCase := auth.NewRegisterUseCase(userRepo, consentRepo, auditRepo, tokenMgr, emailNotifier, log, cfg.SkipEmailVerification)
	loginUseCase := auth.NewLoginUseCase(userRepo, auditRepo, tokenMgr, log)
	refreshTokenUseCase := auth.NewRefreshTokenUseCase(userRepo, tokenMgr, log)
	verifyEmailUseCase := auth.NewVerifyEmailUseCase(userRepo, auditRepo, tokenMgr, log)
	logoutUseCase := auth.NewLogoutUseCase(blacklistService)

	// Inicializar handlers
	registerHandler := authHandler.NewRegisterHandler(registerUseCase, log)
	loginHandler := authHandler.NewLoginHandler(loginUseCase, log)
	refreshHandler := authHandler.NewRefreshTokenHandler(refreshTokenUseCase, log)
	verifyEmailHandler := authHandler.NewVerifyEmailHandler(verifyEmailUseCase, log)
	logoutHandler := authHandler.NewLogoutHandler(logoutUseCase, log)

	// Grupo de rutas de autenticación
	authGroup := router.Group("/api/v1/auth")
	{
		// Rutas públicas con rate limiting
		authGroup.POST("/register",
			rateLimiter.LimitByIP(5, time.Minute),
			registerHandler.Handle,
		)

		authGroup.POST("/login",
			rateLimiter.LimitByIP(5, time.Minute),
			loginHandler.Handle,
		)

		authGroup.POST("/refresh",
			rateLimiter.LimitByIP(10, time.Minute),
			refreshHandler.Handle,
		)

		authGroup.POST("/verify-email",
			rateLimiter.LimitByIP(10, time.Minute),
			verifyEmailHandler.Handle,
		)

		// Rutas protegidas
		protected := authGroup.Group("")
		protected.Use(authMiddleware.Authenticate())
		{
			protected.POST("/logout", logoutHandler.Handle)
		}
	}

	// Grupo de ejemplo de rutas protegidas por rol
	adminGroup := router.Group("/api/v1/admin")
	adminGroup.Use(authMiddleware.Authenticate())
	adminGroup.Use(authMiddleware.RequireRole("admin", "super_admin"))
	{
		// TODO: Implementar endpoints de admin
		adminGroup.GET("/users", func(c *gin.Context) {
			c.JSON(http.StatusOK, gin.H{
				"message": "Admin endpoint - lista de usuarios",
			})
		})
	}
}

/*
RESUMEN DE CAMBIOS:

1. Cambiar (línea ~40):
   sendgridNotifier := notifier.NewSendGridNotifier(&cfg.SendGrid, log)

   Por:
   var emailNotifier notifier.Notifier

   if cfg.EmailProvider == "smtp" {
       emailNotifier = notifier.NewSMTPNotifier(&cfg.SMTP, log)
       log.Info("Using SMTP email provider", logger.String("host", cfg.SMTP.Host))
   } else {
       emailNotifier = notifier.NewSendGridNotifier(&cfg.SendGrid, log)
       log.Info("Using SendGrid email provider")
   }

2. Cambiar (línea ~47):
   registerUseCase := auth.NewRegisterUseCase(userRepo, consentRepo, auditRepo, tokenMgr, sendgridNotifier, log, cfg.SkipEmailVerification)

   Por:
   registerUseCase := auth.NewRegisterUseCase(userRepo, consentRepo, auditRepo, tokenMgr, emailNotifier, log, cfg.SkipEmailVerification)

¡Eso es todo! El resto del código queda igual.
*/
